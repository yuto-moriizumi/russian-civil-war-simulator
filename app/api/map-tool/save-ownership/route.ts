import { NextRequest, NextResponse } from 'next/server';
import { writeFile, mkdir, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

export async function POST(request: NextRequest) {
  // Only allow in development mode
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json(
      { error: 'This endpoint is only available in development mode' },
      { status: 403 }
    );
  }

  try {
    const body = await request.json();
    const { ownership } = body;

    if (!ownership || typeof ownership !== 'object') {
      return NextResponse.json(
        { error: 'Ownership data is required' },
        { status: 400 }
      );
    }

    // Load GeoJSON to get shapeISO for categorization
    const geojsonPath = path.join(process.cwd(), 'public', 'map', 'regions.geojson');
    const geojsonData = JSON.parse(await readFile(geojsonPath, 'utf-8'));
    
    // Create mapping from shapeID to shapeISO for categorization
    const shapeIdToISO: Record<string, string> = {};
    geojsonData.features.forEach((feature: { properties?: { shapeID?: string; shapeISO?: string } }) => {
      const shapeID = feature.properties?.shapeID;
      const shapeISO = feature.properties?.shapeISO;
      if (shapeID && shapeISO) {
        shapeIdToISO[shapeID] = shapeISO;
      }
    });

    // Group regions by country ISO3 code prefix for better organization
    const regionsByFile: Record<string, Record<string, string>> = {
      russia: {},
      easternEurope: {},
      centralEurope: {},
      asia: {},
      middleEast: {},
      other: {},
    };

    for (const [shapeId, countryId] of Object.entries(ownership)) {
      if (typeof countryId !== 'string') continue;
      
      // Get the ISO code for categorization
      const isoCode = shapeIdToISO[shapeId];
      if (!isoCode) {
        // If we can't find ISO code, put in 'other'
        regionsByFile.other[shapeId] = countryId;
        continue;
      }
      
      const prefix = isoCode.substring(0, 2);
      
      // Categorize by region prefix
      if (prefix === 'RU') {
        regionsByFile.russia[shapeId] = countryId;
      } else if (['UA', 'BY', 'MD', 'EE', 'LV', 'LT', 'FI'].includes(prefix)) {
        regionsByFile.easternEurope[shapeId] = countryId;
      } else if (['PL', 'DE', 'CZ', 'SK', 'HU', 'AT', 'RO', 'BG', 'GR'].includes(prefix)) {
        regionsByFile.centralEurope[shapeId] = countryId;
      } else if (['KZ', 'UZ', 'TM', 'KG', 'TJ', 'MN', 'CN'].includes(prefix)) {
        regionsByFile.asia[shapeId] = countryId;
      } else if (['TR', 'IR', 'IQ', 'SY', 'SA', 'AZ', 'AM', 'GE'].includes(prefix)) {
        regionsByFile.middleEast[shapeId] = countryId;
      } else {
        regionsByFile.other[shapeId] = countryId;
      }
    }

    const filesWritten: string[] = [];
    const ownershipDir = path.join(process.cwd(), 'app', 'data', 'map', 'ownership');

    // Ensure directory exists
    if (!existsSync(ownershipDir)) {
      await mkdir(ownershipDir, { recursive: true });
    }

    // Write each file
    for (const [fileName, regions] of Object.entries(regionsByFile)) {
      if (Object.keys(regions).length === 0) continue;

      const filePath = path.join(ownershipDir, `${fileName}.ts`);
      const content = generateTypeScriptFile(fileName, regions);
      
      await writeFile(filePath, content, 'utf-8');
      filesWritten.push(filePath);
    }

    return NextResponse.json({
      success: true,
      message: `Wrote ${filesWritten.length} TypeScript files`,
      filesWritten,
    });
  } catch (error) {
    console.error('Error saving ownership:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

function generateTypeScriptFile(fileName: string, regions: Record<string, string>): string {
  const capitalizedName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
  
  let content = `import { CountryId } from '../../../types/game';\n\n`;
  content += `/**\n * Region ownership for ${capitalizedName}\n * Generated by Map Tool\n */\n`;
  content += `export const ${fileName}Ownership: Record<string, CountryId> = {\n`;

  // Sort by region ID for consistency
  const sortedEntries = Object.entries(regions).sort(([a], [b]) => a.localeCompare(b));
  
  for (const [regionId, countryId] of sortedEntries) {
    content += `  '${regionId}': '${countryId}',\n`;
  }

  content += `};\n`;

  return content;
}

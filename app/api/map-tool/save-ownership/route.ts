import { NextRequest, NextResponse } from 'next/server';
import { writeFile, mkdir } from 'fs/promises';
import { existsSync } from 'fs';
import path from 'path';

export async function POST(request: NextRequest) {
  // Only allow in development mode
  if (process.env.NODE_ENV !== 'development') {
    return NextResponse.json(
      { error: 'This endpoint is only available in development mode' },
      { status: 403 }
    );
  }

  try {
    const body = await request.json();
    const { ownership, format, filename } = body;

    if (!ownership || typeof ownership !== 'object') {
      return NextResponse.json(
        { error: 'Ownership data is required' },
        { status: 400 }
      );
    }

    if (format === 'typescript') {
      // Group regions by country ISO3 code prefix for better organization
      const regionsByFile: Record<string, Record<string, string>> = {
        russia: {},
        easternEurope: {},
        centralEurope: {},
        asia: {},
        middleEast: {},
        other: {},
      };

      for (const [regionId, countryId] of Object.entries(ownership)) {
        if (typeof countryId !== 'string') continue;
        
        const prefix = regionId.substring(0, 2);
        
        // Categorize by region prefix
        if (prefix === 'RU') {
          regionsByFile.russia[regionId] = countryId;
        } else if (['UA', 'BY', 'MD', 'EE', 'LV', 'LT', 'FI'].includes(prefix)) {
          regionsByFile.easternEurope[regionId] = countryId;
        } else if (['PL', 'DE', 'CZ', 'SK', 'HU', 'AT', 'RO', 'BG', 'GR'].includes(prefix)) {
          regionsByFile.centralEurope[regionId] = countryId;
        } else if (['KZ', 'UZ', 'TM', 'KG', 'TJ', 'MN', 'CN'].includes(prefix)) {
          regionsByFile.asia[regionId] = countryId;
        } else if (['TR', 'IR', 'IQ', 'SY', 'SA', 'AZ', 'AM', 'GE'].includes(prefix)) {
          regionsByFile.middleEast[regionId] = countryId;
        } else {
          regionsByFile.other[regionId] = countryId;
        }
      }

      const filesWritten: string[] = [];
      const ownershipDir = path.join(process.cwd(), 'app', 'data', 'map', 'ownership');

      // Ensure directory exists
      if (!existsSync(ownershipDir)) {
        await mkdir(ownershipDir, { recursive: true });
      }

      // Write each file
      for (const [fileName, regions] of Object.entries(regionsByFile)) {
        if (Object.keys(regions).length === 0) continue;

        const filePath = path.join(ownershipDir, `${fileName}.ts`);
        const content = generateTypeScriptFile(fileName, regions);
        
        await writeFile(filePath, content, 'utf-8');
        filesWritten.push(filePath);
      }

      return NextResponse.json({
        success: true,
        message: `Wrote ${filesWritten.length} TypeScript files`,
        filesWritten,
      });
    } else if (format === 'json') {
      // Save as JSON file in the ownership directory
      const ownershipDir = path.join(process.cwd(), 'app', 'data', 'map', 'ownership');
      const jsonFileName = filename || `ownership-${Date.now()}.json`;
      const filePath = path.join(ownershipDir, jsonFileName);

      // Ensure directory exists
      if (!existsSync(ownershipDir)) {
        await mkdir(ownershipDir, { recursive: true });
      }

      await writeFile(filePath, JSON.stringify(ownership, null, 2), 'utf-8');

      return NextResponse.json({
        success: true,
        message: `Wrote JSON file: ${jsonFileName}`,
        filesWritten: [filePath],
      });
    } else {
      return NextResponse.json(
        { error: 'Invalid format. Must be "json" or "typescript"' },
        { status: 400 }
      );
    }
  } catch (error) {
    console.error('Error saving ownership:', error);
    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Unknown error' },
      { status: 500 }
    );
  }
}

function generateTypeScriptFile(fileName: string, regions: Record<string, string>): string {
  const capitalizedName = fileName.charAt(0).toUpperCase() + fileName.slice(1);
  
  let content = `import { CountryId } from '../../../types/game';\n\n`;
  content += `/**\n * Region ownership for ${capitalizedName}\n * Generated by Map Tool\n */\n`;
  content += `export const ${fileName}Ownership: Record<string, CountryId> = {\n`;

  // Sort by region ID for consistency
  const sortedEntries = Object.entries(regions).sort(([a], [b]) => a.localeCompare(b));
  
  for (const [regionId, countryId] of sortedEntries) {
    content += `  '${regionId}': '${countryId}',\n`;
  }

  content += `};\n`;

  return content;
}
